.TH "jpcre2::select< Char_T, Map >::MatchEvaluator" 3 "Thu Apr 9 2020" "Version 10.31.04" "JPCRE2" \" -*- nroff -*-
.ad l
.nh
.SH NAME
jpcre2::select< Char_T, Map >::MatchEvaluator \- This class inherits \fBRegexMatch\fP and provides a similar functionality\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <jpcre2\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBMatchEvaluator\fP ()"
.br
.RI "Default constructor\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP (\fBRegex\fP const *r)"
.br
.RI "This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP (typename \fBMatchEvaluatorCallback\fP< void *, void *, void * >::Callback mef)"
.br
.RI "This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP (typename \fBMatchEvaluatorCallback\fP< \fBNumSub\fP const &, void *, void * >::Callback mef)"
.br
.RI "This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP (typename \fBMatchEvaluatorCallback\fP< \fBNumSub\fP const &, \fBMapNas\fP const &, void * >::Callback mef)"
.br
.RI "This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP (typename \fBMatchEvaluatorCallback\fP< \fBNumSub\fP const &, void *, \fBMapNtN\fP const & >::Callback mef)"
.br
.RI "This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP (typename \fBMatchEvaluatorCallback\fP< \fBNumSub\fP const &, \fBMapNas\fP const &, \fBMapNtN\fP const & >::Callback mef)"
.br
.RI "This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP (typename \fBMatchEvaluatorCallback\fP< void *, \fBMapNas\fP const &, void * >::Callback mef)"
.br
.RI "This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP (typename \fBMatchEvaluatorCallback\fP< void *, \fBMapNas\fP const &, \fBMapNtN\fP const & >::Callback mef)"
.br
.RI "This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP (typename \fBMatchEvaluatorCallback\fP< void *, void *, \fBMapNtN\fP const & >::Callback mef)"
.br
.RI "This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP (\fBMatchEvaluator\fP const &me)"
.br
.RI "This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBoperator=\fP (\fBMatchEvaluator\fP const &me)"
.br
.RI "Overloaded copy-assignment operator\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP (\fBMatchEvaluator\fP &&me)"
.br
.RI "This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBoperator=\fP (\fBMatchEvaluator\fP &&me)"
.br
.RI "This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBsetCallback\fP (typename \fBMatchEvaluatorCallback\fP< void *, void *, void * >::Callback mef)"
.br
.RI "Member function to set a callback function with no vector reference\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBsetCallback\fP (typename \fBMatchEvaluatorCallback\fP< \fBNumSub\fP const &, void *, void * >::Callback mef)"
.br
.RI "This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBsetCallback\fP (typename \fBMatchEvaluatorCallback\fP< \fBNumSub\fP const &, \fBMapNas\fP const &, void * >::Callback mef)"
.br
.RI "This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBsetCallback\fP (typename \fBMatchEvaluatorCallback\fP< \fBNumSub\fP const &, void *, \fBMapNtN\fP const & >::Callback mef)"
.br
.RI "This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBsetCallback\fP (typename \fBMatchEvaluatorCallback\fP< \fBNumSub\fP const &, \fBMapNas\fP const &, \fBMapNtN\fP const & >::Callback mef)"
.br
.RI "This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBsetCallback\fP (typename \fBMatchEvaluatorCallback\fP< void *, \fBMapNas\fP const &, void * >::Callback mef)"
.br
.RI "This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBsetCallback\fP (typename \fBMatchEvaluatorCallback\fP< void *, \fBMapNas\fP const &, \fBMapNtN\fP const & >::Callback mef)"
.br
.RI "This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBsetCallback\fP (typename \fBMatchEvaluatorCallback\fP< void *, void *, \fBMapNtN\fP const & >::Callback mef)"
.br
.RI "This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBclearMatchData\fP ()"
.br
.RI "Clear match data\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBresetMatchData\fP ()"
.br
.RI "Reset match data to initial state\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBreset\fP ()"
.br
.RI "Reset \fBMatchEvaluator\fP to initial state including memory\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBclear\fP ()"
.br
.RI "Clears \fBMatchEvaluator\fP\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBresetErrors\fP ()"
.br
.RI "Call \fBRegexMatch::resetErrors()\fP\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBsetRegexObject\fP (\fBRegex\fP const *r)"
.br
.RI "Call RegexMatch::setRegexObject(r)\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBsetSubject\fP (\fBString\fP const &s)"
.br
.RI "Call \fBRegexMatch::setSubject(String const &s)\fP\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBsetSubject\fP (\fBString\fP const *s)"
.br
.RI "This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBsetModifier\fP (\fBModifier\fP const &s)"
.br
.RI "Call \fBRegexMatch::setModifier(Modifier const& s)\fP\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBsetModifierTable\fP (\fBModifierTable\fP const *mdt)"
.br
.RI "Call \fBRegexMatch::setModifierTable(ModifierTable const * s)\fP\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBsetJpcre2Option\fP (\fBUint\fP x)"
.br
.RI "Call \fBRegexMatch::setJpcre2Option(Uint x)\fP\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBsetPcre2Option\fP (\fBUint\fP x)"
.br
.RI "Call \fBRegexMatch::setPcre2Option\fP (Uint x)\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBsetFindAll\fP (bool x)"
.br
.RI "Call \fBRegexMatch::setFindAll(bool x)\fP\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBsetFindAll\fP ()"
.br
.RI "Call \fBRegexMatch::setFindAll()\fP\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBsetStartOffset\fP (PCRE2_SIZE offset)"
.br
.RI "Call \fBRegexMatch::setStartOffset\fP (PCRE2_SIZE offset)\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBsetMatchContext\fP (MatchContext *match_context)"
.br
.RI "Call \fBRegexMatch::setMatchContext(MatchContext *match_context)\fP\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBsetMatchDataBlock\fP (MatchData *mdt)"
.br
.RI "Call RegexMatch::setMatchDataBlock(MatchContext * mdt);\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBsetBufferSize\fP (PCRE2_SIZE x)"
.br
.RI "Set the buffer size that will be used by pcre2_substitute (\fBreplace()\fP)\&. "
.ti -1c
.RI "PCRE2_SIZE \fBgetBufferSize\fP ()"
.br
.RI "Get the initial buffer size that is being used by internal function pcre2_substitute\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBchangeModifier\fP (\fBModifier\fP const &mod, bool x)"
.br
.RI "Call \fBRegexMatch::changeModifier(Modifier const& mod, bool x)\fP\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBchangeJpcre2Option\fP (\fBUint\fP opt, bool x)"
.br
.RI "Call \fBRegexMatch::changeJpcre2Option(Uint opt, bool x)\fP\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBchangePcre2Option\fP (\fBUint\fP opt, bool x)"
.br
.RI "Call \fBRegexMatch::changePcre2Option(Uint opt, bool x)\fP\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBaddModifier\fP (\fBModifier\fP const &mod)"
.br
.RI "Call \fBRegexMatch::addModifier(Modifier const& mod)\fP\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBaddJpcre2Option\fP (\fBUint\fP x)"
.br
.RI "Call \fBRegexMatch::addJpcre2Option(Uint x)\fP\&. "
.ti -1c
.RI "\fBMatchEvaluator\fP & \fBaddPcre2Option\fP (\fBUint\fP x)"
.br
.RI "Call \fBRegexMatch::addPcre2Option(Uint x)\fP\&. "
.ti -1c
.RI "\fBSIZE_T\fP \fBmatch\fP (void)"
.br
.RI "Perform match and return the match count\&. "
.ti -1c
.RI "\fBString\fP \fBnreplace\fP (bool do_match=true, \fBUint\fP jro=0, \fBSIZE_T\fP *counter=0)"
.br
.RI "Perform regex replace with this match evaluator\&. "
.ti -1c
.RI "\fBString\fP \fBreplace\fP (bool do_match=true, \fBUint\fP ro=0, \fBSIZE_T\fP *counter=0)"
.br
.RI "PCRE2 compatible replace function that uses this \fBMatchEvaluator\fP\&. "
.ti -1c
.RI "virtual int \fBgetErrorNumber\fP () const"
.br
.RI "Returns the last error number\&. "
.ti -1c
.RI "virtual int \fBgetErrorOffset\fP () const"
.br
.RI "Returns the last error offset\&. "
.ti -1c
.RI "virtual \fBString\fP \fBgetErrorMessage\fP () const"
.br
.RI "Returns the last error message\&. "
.ti -1c
.RI "virtual \fBString\fP \fBgetSubject\fP () const"
.br
.RI "Get subject string (by value)\&. "
.ti -1c
.RI "virtual const \fBString\fP * \fBgetSubjectPointer\fP () const"
.br
.RI "Get pointer to subject string\&. "
.ti -1c
.RI "virtual std::string \fBgetModifier\fP () const"
.br
.RI "Calculate modifier string from PCRE2 and JPCRE2 options and return it\&. "
.ti -1c
.RI "virtual \fBModifierTable\fP const  * \fBgetModifierTable\fP ()"
.br
.RI "Get the modifier table that is set,\&. "
.ti -1c
.RI "virtual \fBUint\fP \fBgetPcre2Option\fP () const"
.br
.RI "Get PCRE2 option\&. "
.ti -1c
.RI "virtual \fBUint\fP \fBgetJpcre2Option\fP () const"
.br
.RI "Get JPCRE2 option\&. "
.ti -1c
.RI "virtual PCRE2_SIZE \fBgetStartOffset\fP () const"
.br
.RI "Get offset from where match will start in the subject\&. "
.ti -1c
.RI "virtual \fBVecOff\fP const  * \fBgetMatchStartOffsetVector\fP () const"
.br
.RI "Get pre-set match start offset vector pointer\&. "
.ti -1c
.RI "virtual \fBVecOff\fP const  * \fBgetMatchEndOffsetVector\fP () const"
.br
.RI "Get pre-set match end offset vector pointer\&. "
.ti -1c
.RI "virtual const \fBRegex\fP * \fBgetRegexObject\fP () const"
.br
.RI "Get a pointer to the associated \fBRegex\fP object\&. "
.ti -1c
.RI "virtual \fBVecNum\fP const  * \fBgetNumberedSubstringVector\fP () const"
.br
.RI "Get pointer to numbered substring vector\&. "
.ti -1c
.RI "virtual \fBVecNas\fP const  * \fBgetNamedSubstringVector\fP () const"
.br
.RI "Get pointer to named substring vector\&. "
.ti -1c
.RI "virtual \fBVecNtN\fP const  * \fBgetNameToNumberMapVector\fP () const"
.br
.RI "Get pointer to name to number map vector\&. "
.ti -1c
.RI "virtual MatchContext * \fBgetMatchContext\fP ()"
.br
.RI "Return pointer to the match context that was previously set with \fBsetMatchContext()\fP\&. "
.ti -1c
.RI "virtual MatchData * \fBgetMatchDataBlock\fP ()"
.br
.RI "Get the pointer to the match data block that was set previously with setMatchData() Handling memory is the callers' responsibility\&. "
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename Char_T, template< typename\&.\&.\&. > class Map = std::map>
.br
class jpcre2::select< Char_T, Map >::MatchEvaluator"
This class inherits \fBRegexMatch\fP and provides a similar functionality\&. 

All public member functions from \fBRegexMatch\fP class are publicly available except the following:
.IP "\(bu" 2
setNumberedSubstringVector
.IP "\(bu" 2
setNamedSubstringVector
.IP "\(bu" 2
setNameToNumberMapVector
.IP "\(bu" 2
setMatchStartOffsetVector
.IP "\(bu" 2
setMatchEndOffsetVector
.PP
.PP
The use of above functions is not allowed as the vectors are created according to the callback function you pass\&.
.PP
Each constructor of this class takes a callback function as argument (see \fC\fBMatchEvaluatorCallback\fP\fP)\&.
.PP
It provides a \fBMatchEvaluator::nreplace()\fP function to perform replace operation using native JPCRE2 approach and \fC\fBMatchEvaluator::replace()\fP\fP function for PCRE2 compatible replace operation\&.
.PP
An instance of this class can also be passed with \fC\fBRegexReplace::nreplace()\fP\fP or \fC\fBRegexReplace::replace()\fP\fP function to perform replacement according to this match evaluator\&.
.PP
Match data is stored in vectors, and the vectors are populated according to the callback functions\&. Populated vector data is never deleted but they get overwritten\&. Vector data can be manually zeroed out by calling \fC\fBMatchEvaluator::clearMatchData()\fP\fP\&. If the capacities of those match vectors are desired to to be shrinked too instead of just clearing them, use \fC\fBMatchEvaluator::resetMatchData()\fP\fP instead\&.
.SH "Re-usability of Match Data"
.PP
A match data populated with a callback function that takes only a \fBjp::NumSub\fP vector is not compatible with the data created according to callback function with a \fBjp::MapNas\fP vector\&. Because, for this later callback, \fBjp::MapNas\fP data is required but is not available (only \fBjp::NumSub\fP is available)\&. In such cases, previous Match data can not be used to perform a new replacment operation with this second callback function\&.
.PP
To populate the match vectors, one must call the \fC\fBMatchEvaluator::match()\fP\fP or \fC\fBMatchEvaluator::nreplace()\fP\fP function, they will populate vectors with match data according to call back function\&.
.SS "Example:"
.PP
.nf
jp::String callback5(NumSub const &m, void*, MapNtn const &n){
    return m[0];
}
jp::String callback4(void*, void*, MapNtn const &n){
    return std::to_string(n\&.at("name")); //position of group 'name'\&.
}
jp::String callback2(void*, MapNas const &m, void*){
    return m\&.at('name'); //substring by name
}

jp::MatchEvaluator me;
me\&.setRegexObject(&re)\&.setSubject("string")\&.setCallback(callback5)\&.nreplace();
//In above, nreplace() populates jp::NumSub and jp::MapNtn with match data\&.

me\&.setCallback(callback4)\&.nreplace(false);
//the above uses previous match result (note the 'false') which is OK, 
//because, callback4 requires jp::MapNtn which was made available in the previous operation\&.

//but the following is not OK: (assertion failure)
me\&.setCallback(callback2)\&.nreplace(false);
//because, callback2 requires jp::MapNas data which is not available\&.
//now, this is OK:
me\&.setCallback(callback2)\&.nreplace();
//because, it will recreate those match data including this one (jp::MapNas)\&.
.fi
.PP
.SH "Replace options"
.PP
\fBMatchEvaluator\fP can not take replace options\&. Replace options are taken directly by the replace functions: \fC\fBnreplace()\fP\fP and \fC\fBreplace()\fP\fP\&.
.SH "Using as a match object"
.PP
As it's just a subclass of \fBRegexMatch\fP, it can do all the things that \fBRegexMatch\fP can do, with some restrictions:
.IP "\(bu" 2
matching options are modified to strip off bad options according to replacement (PCRE2_PARTIAL_HARD|PCRE2_PARTIAL_SOFT)\&.
.IP "\(bu" 2
match depends on the callback function\&. Only those vectors will be populated that are implemented by the callback functions so far (multiple callback function will set multiple match data vectors\&.)
.IP "\(bu" 2
match vectors are internal to this class, you can not set them manually (without callback function)\&. (you can get pointers to these vectors with \fC\fBgetNumberedSubstringVector()\fP\fP and related functions)\&.
.PP
.PP
\fBSee also\fP
.RS 4
\fBMatchEvaluatorCallback\fP 
.PP
\fBRegexReplace::nreplace()\fP 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::MatchEvaluator ()\fC [inline]\fP, \fC [explicit]\fP"

.PP
Default constructor\&. Sets \fBcallback::erase\fP as the callback function\&. Removes matched part/s from the subject string if the callback is not changed\&. 
.PP
.nf
jp::Regex re("\s*string");
jp::MatchEvaluator me;
std::cout<<
me\&.setRegexObject(&re);
  \&.setSubject("I am a   string");
  \&.nreplace();
//The above will delete '   string' from the subject
//thus the result will be 'I am a'

.fi
.PP
 
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::MatchEvaluator (\fBRegex\fP const * r)\fC [inline]\fP, \fC [explicit]\fP"

.PP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. Constructor taking a \fBRegex\fP object pointer\&. It sets the associated \fBRegex\fP object and initializes the \fBMatchEvaluator\fP object with \fBcallback::erase\fP callback function\&. Underlying data is not modified\&. 
.PP
\fBParameters\fP
.RS 4
\fIr\fP constant \fBRegex\fP pointer\&. 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::MatchEvaluator (typename \fBMatchEvaluatorCallback\fP< void *, void *, void * >::Callback mef)\fC [inline]\fP, \fC [explicit]\fP"

.PP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. Constructor taking a callback function\&. It calls a corresponding \fBMatchEvaluator::setCallback()\fP function to set the callback function\&. 
.PP
\fBParameters\fP
.RS 4
\fImef\fP Callback function\&. 
.RE
.PP

.PP
References jpcre2::select< Char_T, Map >::MatchEvaluator::setCallback()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::MatchEvaluator (typename \fBMatchEvaluatorCallback\fP< \fBNumSub\fP const &, void *, void * >::Callback mef)\fC [inline]\fP, \fC [explicit]\fP"

.PP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. It calls a corresponding \fBMatchEvaluator::setCallback()\fP function to set the callback function\&. 
.PP
\fBParameters\fP
.RS 4
\fImef\fP Callback function\&. 
.RE
.PP

.PP
References jpcre2::select< Char_T, Map >::MatchEvaluator::setCallback()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::MatchEvaluator (typename \fBMatchEvaluatorCallback\fP< \fBNumSub\fP const &, \fBMapNas\fP const &, void * >::Callback mef)\fC [inline]\fP, \fC [explicit]\fP"

.PP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. It calls a corresponding \fBMatchEvaluator::setCallback()\fP function to set the callback function\&. 
.PP
\fBParameters\fP
.RS 4
\fImef\fP Callback function\&. 
.RE
.PP

.PP
References jpcre2::select< Char_T, Map >::MatchEvaluator::setCallback()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::MatchEvaluator (typename \fBMatchEvaluatorCallback\fP< \fBNumSub\fP const &, void *, \fBMapNtN\fP const & >::Callback mef)\fC [inline]\fP, \fC [explicit]\fP"

.PP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. It calls a corresponding \fBMatchEvaluator::setCallback()\fP function to set the callback function\&. 
.PP
\fBParameters\fP
.RS 4
\fImef\fP Callback function\&. 
.RE
.PP

.PP
References jpcre2::select< Char_T, Map >::MatchEvaluator::setCallback()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::MatchEvaluator (typename \fBMatchEvaluatorCallback\fP< \fBNumSub\fP const &, \fBMapNas\fP const &, \fBMapNtN\fP const & >::Callback mef)\fC [inline]\fP, \fC [explicit]\fP"

.PP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. It calls a corresponding \fBMatchEvaluator::setCallback()\fP function to set the callback function\&. 
.PP
\fBParameters\fP
.RS 4
\fImef\fP Callback function\&. 
.RE
.PP

.PP
References jpcre2::select< Char_T, Map >::MatchEvaluator::setCallback()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::MatchEvaluator (typename \fBMatchEvaluatorCallback\fP< void *, \fBMapNas\fP const &, void * >::Callback mef)\fC [inline]\fP, \fC [explicit]\fP"

.PP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. It calls a corresponding \fBMatchEvaluator::setCallback()\fP function to set the callback function\&. 
.PP
\fBParameters\fP
.RS 4
\fImef\fP Callback function\&. 
.RE
.PP

.PP
References jpcre2::select< Char_T, Map >::MatchEvaluator::setCallback()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::MatchEvaluator (typename \fBMatchEvaluatorCallback\fP< void *, \fBMapNas\fP const &, \fBMapNtN\fP const & >::Callback mef)\fC [inline]\fP, \fC [explicit]\fP"

.PP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. It calls a corresponding \fBMatchEvaluator::setCallback()\fP function to set the callback function\&. 
.PP
\fBParameters\fP
.RS 4
\fImef\fP Callback function\&. 
.RE
.PP

.PP
References jpcre2::select< Char_T, Map >::MatchEvaluator::setCallback()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::MatchEvaluator (typename \fBMatchEvaluatorCallback\fP< void *, void *, \fBMapNtN\fP const & >::Callback mef)\fC [inline]\fP, \fC [explicit]\fP"

.PP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. It calls a corresponding \fBMatchEvaluator::setCallback()\fP function to set the callback function\&. 
.PP
\fBParameters\fP
.RS 4
\fImef\fP Callback function\&. 
.RE
.PP

.PP
References jpcre2::select< Char_T, Map >::MatchEvaluator::setCallback()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::MatchEvaluator (\fBMatchEvaluator\fP const & me)\fC [inline]\fP"

.PP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. Copy constructor\&. 
.PP
\fBParameters\fP
.RS 4
\fIme\fP Reference to \fBMatchEvaluator\fP object 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::MatchEvaluator (\fBMatchEvaluator\fP && me)\fC [inline]\fP"

.PP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. Move constructor\&. This constructor steals resources from the argument\&. It leaves the argument in a valid but indeterminate sate\&. The indeterminate state can be returned to normal by calling \fBreset()\fP on that object\&. 
.PP
\fBParameters\fP
.RS 4
\fIme\fP rvalue reference to a \fBMatchEvaluator\fP object 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::addJpcre2Option (\fBUint\fP x)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Call \fBRegexMatch::addJpcre2Option(Uint x)\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP JPCRE2 option\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.PP
Reimplemented from \fBjpcre2::select< Char_T, Map >::RegexMatch\fP\&.
.PP
References jpcre2::select< Char_T, Map >::RegexMatch::addJpcre2Option()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::addModifier (\fBModifier\fP const & mod)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Call \fBRegexMatch::addModifier(Modifier const& mod)\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fImod\fP modifier string\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.PP
Reimplemented from \fBjpcre2::select< Char_T, Map >::RegexMatch\fP\&.
.PP
References jpcre2::select< Char_T, Map >::RegexMatch::addModifier()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::addPcre2Option (\fBUint\fP x)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Call \fBRegexMatch::addPcre2Option(Uint x)\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP PCRE2 option\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.PP
Reimplemented from \fBjpcre2::select< Char_T, Map >::RegexMatch\fP\&.
.PP
References jpcre2::select< Char_T, Map >::RegexMatch::addPcre2Option()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::changeJpcre2Option (\fBUint\fP opt, bool x)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Call \fBRegexMatch::changeJpcre2Option(Uint opt, bool x)\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIopt\fP JPCRE2 option 
.br
\fIx\fP true (add) or false (remove)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.PP
Reimplemented from \fBjpcre2::select< Char_T, Map >::RegexMatch\fP\&.
.PP
References jpcre2::select< Char_T, Map >::RegexMatch::changeJpcre2Option()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::changeModifier (\fBModifier\fP const & mod, bool x)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Call \fBRegexMatch::changeModifier(Modifier const& mod, bool x)\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fImod\fP modifier string\&. 
.br
\fIx\fP true (add) or false (remove)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.PP
Reimplemented from \fBjpcre2::select< Char_T, Map >::RegexMatch\fP\&.
.PP
References jpcre2::select< Char_T, Map >::RegexMatch::changeModifier()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::changePcre2Option (\fBUint\fP opt, bool x)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Call \fBRegexMatch::changePcre2Option(Uint opt, bool x)\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIopt\fP PCRE2 option\&. 
.br
\fIx\fP true (add) or false (remove)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.PP
Reimplemented from \fBjpcre2::select< Char_T, Map >::RegexMatch\fP\&.
.PP
References jpcre2::select< Char_T, Map >::RegexMatch::changePcre2Option()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::clear ()\fC [inline]\fP, \fC [virtual]\fP"

.PP
Clears \fBMatchEvaluator\fP\&. Returns everything to initial state (some memory may retain for further and faster use)\&. 
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.PP
Reimplemented from \fBjpcre2::select< Char_T, Map >::RegexMatch\fP\&.
.PP
References jpcre2::select< Char_T, Map >::RegexMatch::clear(), and jpcre2::select< Char_T, Map >::MatchEvaluator::clearMatchData()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::clearMatchData ()\fC [inline]\fP"

.PP
Clear match data\&. It clears all match data from all vectors (without shrinking)\&. For shrinking the vectors, use \fC\fBresetMatchData()\fP\fP A call to \fC\fBmatch()\fP\fP or \fBnreplace()\fP will be required to produce match data again\&. 
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.PP
Referenced by jpcre2::select< Char_T, Map >::MatchEvaluator::clear()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> PCRE2_SIZE \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::getBufferSize ()\fC [inline]\fP"

.PP
Get the initial buffer size that is being used by internal function pcre2_substitute\&. 
.PP
\fBReturns\fP
.RS 4
buffer_size 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> virtual \fBString\fP \fBjpcre2::select\fP< Char_T, Map >::RegexMatch::getErrorMessage () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
Returns the last error message\&. 
.PP
\fBReturns\fP
.RS 4
Last error message 
.RE
.PP

.PP
References jpcre2::select< Char_T, Map >::getErrorMessage()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> virtual int \fBjpcre2::select\fP< Char_T, Map >::RegexMatch::getErrorNumber () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
Returns the last error number\&. 
.PP
\fBReturns\fP
.RS 4
Last error number 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> virtual int \fBjpcre2::select\fP< Char_T, Map >::RegexMatch::getErrorOffset () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
Returns the last error offset\&. 
.PP
\fBReturns\fP
.RS 4
Last error offset 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> virtual \fBUint\fP \fBjpcre2::select\fP< Char_T, Map >::RegexMatch::getJpcre2Option () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
Get JPCRE2 option\&. 
.PP
\fBReturns\fP
.RS 4
JPCRE2 options for math operation 
.RE
.PP
\fBSee also\fP
.RS 4
\fBRegex::getJpcre2Option()\fP 
.PP
\fBRegexReplace::getJpcre2Option()\fP 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> virtual MatchContext* \fBjpcre2::select\fP< Char_T, Map >::RegexMatch::getMatchContext ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
Return pointer to the match context that was previously set with \fBsetMatchContext()\fP\&. Handling memory is the callers' responsibility\&. 
.PP
\fBReturns\fP
.RS 4
pointer to the match context (default: null)\&. 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> virtual MatchData* \fBjpcre2::select\fP< Char_T, Map >::RegexMatch::getMatchDataBlock ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
Get the pointer to the match data block that was set previously with setMatchData() Handling memory is the callers' responsibility\&. 
.PP
\fBReturns\fP
.RS 4
pointer to the match data (default: null)\&. 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> virtual \fBVecOff\fP const* \fBjpcre2::select\fP< Char_T, Map >::RegexMatch::getMatchEndOffsetVector () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
Get pre-set match end offset vector pointer\&. The pointer must be set with \fBRegexMatch::setMatchEndOffsetVector()\fP beforehand for this to work i\&.e it is just a convenience method to get the pre-set vector pointer\&. 
.PP
\fBReturns\fP
.RS 4
pointer to the const end offset vector 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> virtual \fBVecOff\fP const* \fBjpcre2::select\fP< Char_T, Map >::RegexMatch::getMatchStartOffsetVector () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
Get pre-set match start offset vector pointer\&. The pointer must be set with \fBRegexMatch::setMatchStartOffsetVector()\fP beforehand for this to work i\&.e it is just a convenience method to get the pre-set vector pointer\&. 
.PP
\fBReturns\fP
.RS 4
pointer to the const match start offset vector 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> virtual std::string \fBjpcre2::select\fP< Char_T, Map >::RegexMatch::getModifier () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
Calculate modifier string from PCRE2 and JPCRE2 options and return it\&. Do remember that modifiers (or PCRE2 and JPCRE2 options) do not change or get initialized as long as you don't do that explicitly\&. Calling \fBRegexMatch::setModifier()\fP will re-set them\&.
.PP
\fBMixed or combined modifier\fP\&.
.PP
Some modifier may include other modifiers i\&.e they have the same meaning of some modifiers combined together\&. For example, the 'n' modifier includes the 'u' modifier and together they are equivalent to \fCPCRE2_UTF | PCRE2_UCP\fP\&. When you set a modifier like this, both options get set, and when you remove the 'n' modifier (with \fC\fBRegexMatch::changeModifier()\fP\fP), both will get removed\&. 
.PP
\fBReturns\fP
.RS 4
Calculated modifier string (std::string) 
.RE
.PP
\fBSee also\fP
.RS 4
\fBRegex::getModifier()\fP 
.PP
\fBRegexReplace::getModifier()\fP 
.RE
.PP

.PP
References jpcre2::ModifierTable::fromMatchOption()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> virtual \fBModifierTable\fP const* \fBjpcre2::select\fP< Char_T, Map >::RegexMatch::getModifierTable ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
Get the modifier table that is set,\&. 
.PP
\fBReturns\fP
.RS 4
pointer to constant \fBModifierTable\fP\&. 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> virtual \fBVecNas\fP const* \fBjpcre2::select\fP< Char_T, Map >::RegexMatch::getNamedSubstringVector () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
Get pointer to named substring vector\&. 
.PP
\fBReturns\fP
.RS 4
Pointer to const named substring vector\&. 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> virtual \fBVecNtN\fP const* \fBjpcre2::select\fP< Char_T, Map >::RegexMatch::getNameToNumberMapVector () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
Get pointer to name to number map vector\&. 
.PP
\fBReturns\fP
.RS 4
Pointer to const name to number map vector\&. 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> virtual \fBVecNum\fP const* \fBjpcre2::select\fP< Char_T, Map >::RegexMatch::getNumberedSubstringVector () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
Get pointer to numbered substring vector\&. 
.PP
\fBReturns\fP
.RS 4
Pointer to const numbered substring vector\&. 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> virtual \fBUint\fP \fBjpcre2::select\fP< Char_T, Map >::RegexMatch::getPcre2Option () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
Get PCRE2 option\&. 
.PP
\fBReturns\fP
.RS 4
PCRE2 option for match operation 
.RE
.PP
\fBSee also\fP
.RS 4
\fBRegex::getPcre2Option()\fP 
.PP
\fBRegexReplace::getPcre2Option()\fP 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> virtual const \fBRegex\fP* \fBjpcre2::select\fP< Char_T, Map >::RegexMatch::getRegexObject () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
Get a pointer to the associated \fBRegex\fP object\&. If no actual \fBRegex\fP object is associated, null is returned\&. 
.PP
\fBReturns\fP
.RS 4
A pointer to the associated constant \fBRegex\fP object or null\&. 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> virtual PCRE2_SIZE \fBjpcre2::select\fP< Char_T, Map >::RegexMatch::getStartOffset () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
Get offset from where match will start in the subject\&. 
.PP
\fBReturns\fP
.RS 4
Start offset 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> virtual \fBString\fP \fBjpcre2::select\fP< Char_T, Map >::RegexMatch::getSubject () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
Get subject string (by value)\&. 
.PP
\fBReturns\fP
.RS 4
subject string 
.RE
.PP
\fBSee also\fP
.RS 4
\fBRegexReplace::getSubject()\fP 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> virtual const \fBString\fP* \fBjpcre2::select\fP< Char_T, Map >::RegexMatch::getSubjectPointer () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
Get pointer to subject string\&. Data can not be changed with this pointer\&. 
.PP
\fBReturns\fP
.RS 4
constant subject string pointer 
.RE
.PP
\fBSee also\fP
.RS 4
\fBRegexReplace::getSubjectPointer()\fP 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBSIZE_T\fP \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::match (void)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Perform match and return the match count\&. This function strips off matching options (PCRE2_PARTIAL_HARD|PCRE2_PARTIAL_SOFT) that are considered bad options for replacement operation and then calls \fBRegexMatch::match()\fP to perform the match\&. 
.PP
\fBReturns\fP
.RS 4
match count\&. 
.RE
.PP

.PP
Reimplemented from \fBjpcre2::select< Char_T, Map >::RegexMatch\fP\&.
.PP
References jpcre2::select< Char_T, Map >::RegexMatch::changePcre2Option(), and jpcre2::select< Char_T, Map >::RegexMatch::match()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map> \fBjpcre2::select\fP< Char_T, Map >::\fBString\fP \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::nreplace (bool do_match = \fCtrue\fP, \fBUint\fP jro = \fC0\fP, \fBSIZE_T\fP * counter = \fC0\fP)"

.PP
Perform regex replace with this match evaluator\&. This is a JPCRE2 native replace function (thus the name nreplace)\&. It uses the \fC\fBMatchEvaluatorCallback\fP\fP function that was set with a constructor or \fC\fBMatchEvaluator::setCallback()\fP\fP function to generate the replacement strings on the fly\&. The string returned by the callback function will be treated as literal and will not go through any further processing\&.
.PP
This function performs a new match everytime it is called unless it is passed with a boolean \fCfalse\fP as the first argument\&. To use existing match data that was created by a previous \fC\fBMatchEvaluator::nreplace()\fP\fP or \fC\fBMatchEvaluator::match()\fP\fP, call this function with boolean \fCfalse\fP as the first argument\&.
.SH "Complexity"
.PP
.IP "1." 4
Changes in replace related option takes effect without a re-match\&.
.IP "2." 4
Changes in match related option (e\&.g start offset) needs a re-match to take effect\&.
.IP "3." 4
To re-use existing match data, callback function must be compatible with the data, otherwise assertion error\&.
.IP "4." 4
If the associated \fBRegex\fP object or subject string changes, a new match must be performed, trying to use the existing match data in such cases is undefined behavior\&.
.PP
.PP
\fBParameters\fP
.RS 4
\fIdo_match\fP Perform a new matching operation if true, otherwise use existing match data\&. 
.br
\fIjro\fP JPCRE2 replace options\&. 
.br
\fIcounter\fP Pointer to a counter to store the number of replacement done\&. 
.RE
.PP
\fBReturns\fP
.RS 4
resultant string after replace\&. 
.RE
.PP
\fBSee also\fP
.RS 4
\fBMatchEvaluator\fP\&. 
.PP
\fBMatchEvaluatorCallback\fP\&. 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::operator= (\fBMatchEvaluator\fP && me)\fC [inline]\fP"

.PP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. Overloaded move-assignment operator\&. It steals resources from the argument\&. It leaves the argument in a valid but indeterminate sate\&. The indeterminate state can be returned to normal by calling \fBreset()\fP on that object\&. 
.PP
\fBParameters\fP
.RS 4
\fIme\fP rvalue reference to a \fBMatchEvaluator\fP object 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP
\fBSee also\fP
.RS 4
\fBMatchEvaluator(MatchEvaluator&& me)\fP 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::operator= (\fBMatchEvaluator\fP const & me)\fC [inline]\fP"

.PP
Overloaded copy-assignment operator\&. 
.PP
\fBParameters\fP
.RS 4
\fIme\fP \fBMatchEvaluator\fP object 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map> \fBjpcre2::select\fP< Char_T, Map >::\fBString\fP \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::replace (bool do_match = \fCtrue\fP, \fBUint\fP ro = \fC0\fP, \fBSIZE_T\fP * counter = \fC0\fP)"

.PP
PCRE2 compatible replace function that uses this \fBMatchEvaluator\fP\&. Performs regex replace with pcre2_substitute function by generating the replacement strings dynamically with \fBMatchEvaluator\fP callback\&. The string returned by callback function is processed by internal pcre2_substitute, thus allowing all options that are provided by PCRE2 itself\&.
.PP
This function performs a new match everytime it is called unless it is passed with a boolean \fCfalse\fP as the first argument\&.
.SH "Complexity"
.PP
.IP "1." 4
Changes in replace related option takes effect without a re-match\&.
.IP "2." 4
Changes in match related option (e\&.g start offset) needs a re-match to take effect\&.
.IP "3." 4
To re-use existing match data, callback function must be compatible with the data, otherwise assertion error\&.
.IP "4." 4
If the associated \fBRegex\fP object or subject string changes, a new match must be performed, trying to use the existing match data in such cases is undefined behavior\&.
.PP
.PP
\fBParameters\fP
.RS 4
\fIdo_match\fP perform a new match if true, otherwise use existing data\&. 
.br
\fIro\fP replace related PCRE2 options\&. 
.br
\fIcounter\fP Pointer to a counter to store the number of replacement done\&. 
.RE
.PP
\fBReturns\fP
.RS 4
resultant string after replacement\&. 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::reset ()\fC [inline]\fP, \fC [virtual]\fP"

.PP
Reset \fBMatchEvaluator\fP to initial state including memory\&. 
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.PP
Reimplemented from \fBjpcre2::select< Char_T, Map >::RegexMatch\fP\&.
.PP
References jpcre2::select< Char_T, Map >::RegexMatch::reset(), and jpcre2::select< Char_T, Map >::MatchEvaluator::resetMatchData()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::resetErrors ()\fC [inline]\fP, \fC [virtual]\fP"

.PP
Call \fBRegexMatch::resetErrors()\fP\&. 
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.PP
Reimplemented from \fBjpcre2::select< Char_T, Map >::RegexMatch\fP\&.
.PP
References jpcre2::select< Char_T, Map >::RegexMatch::resetErrors()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::resetMatchData ()\fC [inline]\fP"

.PP
Reset match data to initial state\&. It deletes all match data from all vectors shrinking their capacity\&. A call to \fC\fBmatch()\fP\fP or \fBnreplace()\fP will be required to produce match data again\&. 
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.PP
Referenced by jpcre2::select< Char_T, Map >::MatchEvaluator::reset()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::setBufferSize (PCRE2_SIZE x)\fC [inline]\fP"

.PP
Set the buffer size that will be used by pcre2_substitute (\fBreplace()\fP)\&. If buffer size proves to be enough to fit the resultant string from each match (not the total resultant string), it will yield one less call to pcre2_substitute for each match\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP buffer size\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::setCallback (typename \fBMatchEvaluatorCallback\fP< \fBNumSub\fP const &, \fBMapNas\fP const &, \fBMapNtN\fP const & >::Callback mef)\fC [inline]\fP"

.PP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. Sets a callback function with a \fBjp::NumSub\fP, \fBjp::MapNas\fP, \fBjp::MapNtN\fP\&. You will be working with references of the constant vectors\&. For maps, you won't be able to use \fC[]\fP operator with reference to constant map, use at() instead: 
.PP
.nf
map_nas["word"]; //wrong
map_nas\&.at("word"); //ok 

.fi
.PP
.PP
If you want to use \fC[]\fP operator with maps, make a copy: 
.PP
.nf
jp::MapNas mn = map_nas;
mn["word"]; //ok

.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fImef\fP Callback function\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::setCallback (typename \fBMatchEvaluatorCallback\fP< \fBNumSub\fP const &, \fBMapNas\fP const &, void * >::Callback mef)\fC [inline]\fP"

.PP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. Sets a callback function with a \fBjp::NumSub\fP and \fBjp::MapNas\fP\&. You will be working with references of the constant vectors\&. For maps, you won't be able to use \fC[]\fP operator with reference to constant map, use at() instead: 
.PP
.nf
map_nas["word"]; //wrong
map_nas\&.at("word"); //ok 

.fi
.PP
.PP
If you want to use \fC[]\fP operator with maps, make a copy: 
.PP
.nf
jp::MapNas mn = map_nas;
mn["word"]; //ok

.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fImef\fP Callback function\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::setCallback (typename \fBMatchEvaluatorCallback\fP< \fBNumSub\fP const &, void *, \fBMapNtN\fP const & >::Callback mef)\fC [inline]\fP"

.PP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. Sets a callback function with a \fBjp::NumSub\fP and \fBjp::MapNtN\fP\&. You will be working with references of the constant vectors\&. For maps, you won't be able to use \fC[]\fP operator with reference to constant map, use at() instead: 
.PP
.nf
map_ntn["word"]; //wrong
map_ntn\&.at("word"); //ok 

.fi
.PP
.PP
If you want to use \fC[]\fP operator with maps, make a copy: 
.PP
.nf
jp::MapNtN mn = map_ntn;
mn["word"]; //ok

.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fImef\fP Callback function\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::setCallback (typename \fBMatchEvaluatorCallback\fP< \fBNumSub\fP const &, void *, void * >::Callback mef)\fC [inline]\fP"

.PP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. Sets a callback function with a \fBjp::NumSub\fP vector\&. You will be working with a reference to the constant vector\&. 
.PP
\fBParameters\fP
.RS 4
\fImef\fP Callback function\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::setCallback (typename \fBMatchEvaluatorCallback\fP< void *, \fBMapNas\fP const &, \fBMapNtN\fP const & >::Callback mef)\fC [inline]\fP"

.PP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. Sets a callback function with a \fBjp::MapNas\fP, \fBjp::MapNtN\fP\&. You will be working with reference of the constant vector\&. For maps, you won't be able to use \fC[]\fP operator with reference to constant map, use at() instead: 
.PP
.nf
map_nas["word"]; //wrong
map_nas\&.at("word"); //ok 

.fi
.PP
.PP
If you want to use \fC[]\fP operator with maps, make a copy: 
.PP
.nf
jp::MapNas mn = map_nas;
mn["word"]; //ok

.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fImef\fP Callback function\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::setCallback (typename \fBMatchEvaluatorCallback\fP< void *, \fBMapNas\fP const &, void * >::Callback mef)\fC [inline]\fP"

.PP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. Sets a callback function with a \fBjp::MapNas\fP\&. You will be working with reference of the constant vector\&. For maps, you won't be able to use \fC[]\fP operator with reference to constant map, use at() instead: 
.PP
.nf
map_nas["word"]; //wrong
map_nas\&.at("word"); //ok 

.fi
.PP
.PP
If you want to use \fC[]\fP operator with maps, make a copy: 
.PP
.nf
jp::MapNas mn = map_nas;
mn["word"]; //ok

.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fImef\fP Callback function\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::setCallback (typename \fBMatchEvaluatorCallback\fP< void *, void *, \fBMapNtN\fP const & >::Callback mef)\fC [inline]\fP"

.PP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. \&.\&.\&. Sets a callback function with a \fBjp::MapNtN\fP\&. You will be working with references of the constant vectors\&. For maps, you won't be able to use \fC[]\fP operator with reference to constant map, use at() instead: 
.PP
.nf
map_ntn["word"]; //wrong
map_ntn\&.at("word"); //ok 

.fi
.PP
.PP
If you want to use \fC[]\fP operator with maps, make a copy: 
.PP
.nf
jp::MapNtN mn = map_ntn;
mn["word"]; //ok

.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fImef\fP Callback function\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::setCallback (typename \fBMatchEvaluatorCallback\fP< void *, void *, void * >::Callback mef)\fC [inline]\fP"

.PP
Member function to set a callback function with no vector reference\&. Callback function is always overwritten\&. The implemented vectors are set to be filled with match data\&. Other vectors that were set previously, are not unset and thus they will be filled with match data too when \fC\fBmatch()\fP\fP or \fC\fBnreplace()\fP\fP is called\&. 
.PP
\fBParameters\fP
.RS 4
\fImef\fP Callback function\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.PP
Referenced by jpcre2::select< Char_T, Map >::MatchEvaluator::MatchEvaluator()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::setFindAll ()\fC [inline]\fP, \fC [virtual]\fP"

.PP
Call \fBRegexMatch::setFindAll()\fP\&. 
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.PP
Reimplemented from \fBjpcre2::select< Char_T, Map >::RegexMatch\fP\&.
.PP
References jpcre2::select< Char_T, Map >::RegexMatch::setFindAll()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::setFindAll (bool x)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Call \fBRegexMatch::setFindAll(bool x)\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP true if global match, false otherwise\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.PP
Reimplemented from \fBjpcre2::select< Char_T, Map >::RegexMatch\fP\&.
.PP
References jpcre2::select< Char_T, Map >::RegexMatch::setFindAll()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::setJpcre2Option (\fBUint\fP x)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Call \fBRegexMatch::setJpcre2Option(Uint x)\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP JPCRE2 option value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.PP
Reimplemented from \fBjpcre2::select< Char_T, Map >::RegexMatch\fP\&.
.PP
References jpcre2::select< Char_T, Map >::RegexMatch::setJpcre2Option()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::setMatchContext (MatchContext * match_context)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Call \fBRegexMatch::setMatchContext(MatchContext *match_context)\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fImatch_context\fP pointer to match context\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.PP
Reimplemented from \fBjpcre2::select< Char_T, Map >::RegexMatch\fP\&.
.PP
References jpcre2::select< Char_T, Map >::RegexMatch::setMatchContext()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::setMatchDataBlock (MatchData * mdt)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Call RegexMatch::setMatchDataBlock(MatchContext * mdt);\&. 
.PP
\fBParameters\fP
.RS 4
\fImdt\fP pointer to match data block 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.PP
Reimplemented from \fBjpcre2::select< Char_T, Map >::RegexMatch\fP\&.
.PP
References jpcre2::select< Char_T, Map >::RegexMatch::setMatchDataBlock()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::setModifier (\fBModifier\fP const & s)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Call \fBRegexMatch::setModifier(Modifier const& s)\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIs\fP modifier string\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.PP
Reimplemented from \fBjpcre2::select< Char_T, Map >::RegexMatch\fP\&.
.PP
References jpcre2::select< Char_T, Map >::RegexMatch::setModifier()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::setModifierTable (\fBModifierTable\fP const * mdt)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Call \fBRegexMatch::setModifierTable(ModifierTable const * s)\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fImdt\fP pointer to \fBModifierTable\fP object\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.PP
Reimplemented from \fBjpcre2::select< Char_T, Map >::RegexMatch\fP\&.
.PP
References jpcre2::select< Char_T, Map >::RegexMatch::setModifierTable()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::setPcre2Option (\fBUint\fP x)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Call \fBRegexMatch::setPcre2Option\fP (Uint x)\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP PCRE2 option value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.PP
Reimplemented from \fBjpcre2::select< Char_T, Map >::RegexMatch\fP\&.
.PP
References jpcre2::select< Char_T, Map >::RegexMatch::setPcre2Option()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::setRegexObject (\fBRegex\fP const * r)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Call RegexMatch::setRegexObject(r)\&. 
.PP
\fBParameters\fP
.RS 4
\fIr\fP constant \fBRegex\fP object pointer 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.PP
Reimplemented from \fBjpcre2::select< Char_T, Map >::RegexMatch\fP\&.
.PP
References jpcre2::select< Char_T, Map >::RegexMatch::setRegexObject()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::setStartOffset (PCRE2_SIZE offset)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Call \fBRegexMatch::setStartOffset\fP (PCRE2_SIZE offset)\&. 
.PP
\fBParameters\fP
.RS 4
\fIoffset\fP match start offset in the subject\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.PP
Reimplemented from \fBjpcre2::select< Char_T, Map >::RegexMatch\fP\&.
.PP
References jpcre2::select< Char_T, Map >::RegexMatch::setStartOffset()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::setSubject (\fBString\fP const & s)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Call \fBRegexMatch::setSubject(String const &s)\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIs\fP subject string\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.PP
Reimplemented from \fBjpcre2::select< Char_T, Map >::RegexMatch\fP\&.
.PP
References jpcre2::select< Char_T, Map >::RegexMatch::setSubject()\&.
.SS "template<typename Char_T , template< typename\&.\&.\&. > class Map = std::map> \fBMatchEvaluator\fP& \fBjpcre2::select\fP< Char_T, Map >::MatchEvaluator::setSubject (\fBString\fP const * s)\fC [inline]\fP, \fC [virtual]\fP"

.PP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. 
.PP
\fBParameters\fP
.RS 4
\fIs\fP constant subject string by pointer 
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the calling \fBMatchEvaluator\fP object\&. 
.RE
.PP

.PP
Reimplemented from \fBjpcre2::select< Char_T, Map >::RegexMatch\fP\&.
.PP
References jpcre2::select< Char_T, Map >::RegexMatch::setSubject()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for JPCRE2 from the source code\&.
