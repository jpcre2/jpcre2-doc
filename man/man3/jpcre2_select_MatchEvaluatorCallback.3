.TH "jpcre2::select< Char_T, BS >::MatchEvaluatorCallback< T1, T2, T3 >" 3 "Fri Jul 21 2017" "Version 10.30.02" "JPCRE2" \" -*- nroff -*-
.ad l
.nh
.SH NAME
jpcre2::select< Char_T, BS >::MatchEvaluatorCallback< T1, T2, T3 > \- This class contains a typedef of a function pointer or a templated function wrapper (\fCstd::function\fP) to provide callback function to the \fC\fBMatchEvaluator\fP\fP\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <jpcre2\&.hpp>\fP
.SH "Detailed Description"
.PP 

.SS "template<typename Char_T, Ush BS = sizeof( Char_T ) * CHAR_BIT>
.br
template<typename T1, typename T2, typename T3>
.br
struct jpcre2::select< Char_T, BS >::MatchEvaluatorCallback< T1, T2, T3 >"
This class contains a typedef of a function pointer or a templated function wrapper (\fCstd::function\fP) to provide callback function to the \fC\fBMatchEvaluator\fP\fP\&. 

\fCstd::function\fP is used when \fC>=C++11\fP is being used , otherwise function pointer is used\&. You can force using function pointer instead of \fCstd::function\fP when \fC>=C++11\fP is used by defining the macro \fCJPCRE2_USE_FUNCTION_POINTER_CALLBACK\fP before including \fBjpcre2\&.hpp\fP\&. If you are using lambda function with capture, you must use the \fCstd::function\fP approach\&.
.PP
The callback function takes exactly three positional arguments: 
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIT1\fP The first argument must be \fC\fBjp::NumSub\fP const &\fP aka \fCstd::vector<String> const &\fP (or \fCvoid*\fP if not needed)\&. 
.br
\fIT2\fP The second argument must be \fC\fBjp::MapNas\fP const &\fP aka \fCstd::map<String, size_t> const &\fP (or \fCvoid*\fP if not needed)\&. 
.br
\fIT3\fP The third argument must be \fC\fBjp::MapNtN\fP const &\fP aka \fCstd::map<String, String> const &\fP (or \fCvoid*\fP if not needed)\&.
.RE
.PP
\fBExamples:\fP 
.PP
.nf
typedef jpcre2::select<char> jp;
jp::String myCallback1(jp::NumSub const &m1, void*, void*){
    return "("+m1[0]+")";
}

jp::String myCallback2(jp::NumSub const &m1, jp::MapNas const &m2, void*){
    return "("+m1[0]+"/"+m2\&.at("total")+")";
}
//Now you can pass these functions in MatchEvaluator constructors to create a match evaluator
jp::MatchEvaluator me1(myCallback1); 

//Examples with lambda (>=C++11)
jp::MatchEvaluator me2([](jp::NumSub const &m1, void*, void*)
                        {
                            return "("+m1[0]+")";
                        });

.fi
.PP
 
.PP
\fBSee also:\fP
.RS 4
\fBMatchEvaluator\fP 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for JPCRE2 from the source code\&.
